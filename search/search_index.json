{
    "docs": [
        {
            "location": "/",
            "text": "Welcome to the SAFE documentation site! This site contains all the documentation you'll need to quickly starting creating SAFE apps in F#. If you've not heard of SAFE before, please feel free to start with the \nintroduction\n. Alternatively, you can immediately try out the \nquick start\n guide and tutorial, or simply browse through the documentation.\n\n\nIf there's anything missing from here, please feel free to add the documentation directly (or supply an issue) to the \nGitHub repository\n.\n\n\nWe hope you enjoy using SAFE as much as we do!\n\n\nThe SAFE team.",
            "title": "Home"
        },
        {
            "location": "/intro/",
            "text": "What is SAFE?\n\n\nThe SAFE stack is an \nopen-source, free, flexible\n end-to-end, \nfunctional-first\n stack for \ncloud-ready web applications\n that emphasizes \ntype-safe programming\n.\n\n\nThe SAFE stack allows you to \ndevelop client/server web applications almost entirely in \nF#\n, without needing to compromise and shoehorn your codebase into an object-oriented framework or library, and without needing you to be an expert in CSS or HTML to create compelling, rich client-side web applications.\n\n\nThe SAFE stack is made up of four components:\n\n\n\n\nA \nweb server\n running on .NET Core for hosting back-end services in F#\n\n\nA \nhosting platform\n that provides simple, scalable deployment models plus associated platform services for application developers\n\n\nA mechanism to run F# in the web browser for \nclient-side delivery of F#\n\n\nAn F# programming model for \nclient-side user interfaces\n\n\n\n\nWhy SAFE?\n\n\nSAFE provides developers with a simple and consistent programming model for developing rich, scalable web-enabled applications that can run on multiple platforms. SAFE takes advantage of F#'s mix of a functional-first experience backed by the powerful and mature .NET framework to provide a type-safe, reliable experience that leads to the \"pit of success\".\n\n\n\n\nCreate client / server applications entirely in F#\n\n\nRe-use development skills on client and server\n\n\nRapidly create rich client-side web applications with no Javascript knowledge\n\n\nRuns on the latest .NET Core (and tested daily by Microsoft)\n\n\nRapid development cycle with support for hot module reloading\n\n\nInteract with native Javascript libraries whenever needed\n\n\nCreate client-side applications purely in F#, with full type checking for safety\n\n\nSeamlessly share code between client and server",
            "title": "Introduction"
        },
        {
            "location": "/intro/#what-is-safe",
            "text": "The SAFE stack is an  open-source, free, flexible  end-to-end,  functional-first  stack for  cloud-ready web applications  that emphasizes  type-safe programming .  The SAFE stack allows you to  develop client/server web applications almost entirely in  F# , without needing to compromise and shoehorn your codebase into an object-oriented framework or library, and without needing you to be an expert in CSS or HTML to create compelling, rich client-side web applications.  The SAFE stack is made up of four components:   A  web server  running on .NET Core for hosting back-end services in F#  A  hosting platform  that provides simple, scalable deployment models plus associated platform services for application developers  A mechanism to run F# in the web browser for  client-side delivery of F#  An F# programming model for  client-side user interfaces",
            "title": "What is SAFE?"
        },
        {
            "location": "/intro/#why-safe",
            "text": "SAFE provides developers with a simple and consistent programming model for developing rich, scalable web-enabled applications that can run on multiple platforms. SAFE takes advantage of F#'s mix of a functional-first experience backed by the powerful and mature .NET framework to provide a type-safe, reliable experience that leads to the \"pit of success\".   Create client / server applications entirely in F#  Re-use development skills on client and server  Rapidly create rich client-side web applications with no Javascript knowledge  Runs on the latest .NET Core (and tested daily by Microsoft)  Rapid development cycle with support for hot module reloading  Interact with native Javascript libraries whenever needed  Create client-side applications purely in F#, with full type checking for safety  Seamlessly share code between client and server",
            "title": "Why SAFE?"
        },
        {
            "location": "/quickstart/",
            "text": "This page provides some basic guidance on getting up and running with your first SAFE application.\n\n\nInstall pre-requisites\n\n\nYou'll need to install the following pre-requisites in order to build SAFE applications\n\n\n\n\nThe \n.NET Core SDK 2.x\n.\n\n\nThe \nYarn\n package manager.\n\n\nNode 8.x\n installed for the front end components.\n\n\nIf you're running on OSX or Linux, you'll also need to install \nMono\n.\n\n\n\n\nInstall an F# code editor\n\n\nYou'll also want an IDE to create F# applications. We recommend one of the following great IDEs.\n\n\n\n\nVS Code\n + \nIonide\n extension\n\n\nVisual Studio 2017\n\n\nJetbrains Rider\n\n\n\n\nCreate your first SAFE app\n\n\n\n\nCreate a new directory on your machine\n\n\nOpen a command prompt\n\n\nEnter \ndotnet new -i SAFE.Template\n to install the \nSAFE project template\n (you only need to do this once!)\n\n\nEnter \ndotnet new SAFE -lang F#\n to create a new SAFE project\n\n\nEnter \nbuild.cmd run\n (Windows) or \n./build.sh run\n (Linux / OSX)\n\n\n\n\nCongratulations! After a short delay, you'll be presented with a basic SAFE application running in your browser! The app will by default run in \"development mode\", which means it automatically watches your project for changes. Whenever you save a file in the client project it will refresh the browser \nautomatically\n; if you save a file in the server project it will restart the server in the background.\n\n\nTip: Take a look at the \ntemplate options\n. There are several ways to customise the default application, including server technology and client/server communication technology.",
            "title": "Quick Start"
        },
        {
            "location": "/quickstart/#install-pre-requisites",
            "text": "You'll need to install the following pre-requisites in order to build SAFE applications   The  .NET Core SDK 2.x .  The  Yarn  package manager.  Node 8.x  installed for the front end components.  If you're running on OSX or Linux, you'll also need to install  Mono .",
            "title": "Install pre-requisites"
        },
        {
            "location": "/quickstart/#install-an-f-code-editor",
            "text": "You'll also want an IDE to create F# applications. We recommend one of the following great IDEs.   VS Code  +  Ionide  extension  Visual Studio 2017  Jetbrains Rider",
            "title": "Install an F# code editor"
        },
        {
            "location": "/quickstart/#create-your-first-safe-app",
            "text": "Create a new directory on your machine  Open a command prompt  Enter  dotnet new -i SAFE.Template  to install the  SAFE project template  (you only need to do this once!)  Enter  dotnet new SAFE -lang F#  to create a new SAFE project  Enter  build.cmd run  (Windows) or  ./build.sh run  (Linux / OSX)   Congratulations! After a short delay, you'll be presented with a basic SAFE application running in your browser! The app will by default run in \"development mode\", which means it automatically watches your project for changes. Whenever you save a file in the client project it will refresh the browser  automatically ; if you save a file in the server project it will restart the server in the background.  Tip: Take a look at the  template options . There are several ways to customise the default application, including server technology and client/server communication technology.",
            "title": "Create your first SAFE app"
        },
        {
            "location": "/safe-template/",
            "text": "The \nSAFE Template\n is a \ndotnet CLI template\n for SAFE Stack projects, designed to get you up and running as quickly as possible, with flexible options to suit your application.\n\n\nThe template gets you up and running with 3 core components of the stack:\n\n\n\n\nSaturn\n, \nGiraffe\n or \nSuave\n.\n\n\nFable\n\n\nElmish\n\n\n\n\nCurrently, the template does not include any Azure / other Cloud integration. Refer to the \nSAFE-Bookstore\n repository for an example of deploying to Azure and for more details about this stack. We're working on fixing this soon!\n\n\nUsing the template\n\n\nRefer to the \nQuick Start guide\n to see basic guidance on how to use the template.\n\n\nTemplate options\n\n\nThe template provides the ability to customise the created application. You can see template version and available options by running  \ndotnet new SAFE --help\n.\n\n\nServer\n\n\nConfigures the SAFE app to use one of three different back-end hosting platforms.\n\n\nUsage: \ndotnet new SAFE --Server <server>\n\n\nWhere \n<server>\n is one of:\n\n\n\n\nsaturn\n: Creates a SAFE app running on Saturn on top of Giraffe \n(recommended)\n.\n\n\ngiraffe\n: Creates a SAFE app running on Giraffe only.\n\n\nsuave\n: Creates a SAFE app running on Suave.\n\n\n\n\nFulma\n\n\nConfigures the SAFE app to apply \nFulma\n bindings to the UI template.\n\n\nUsage: \ndotnet new SAFE --Fulma <template>\n\n\nWhere \ntemplate\n is one of:\n\n\n\n\nnone\n: don't add Fulma bindings at all\n\n\nbasic\n: adds Fulma basic template\n\n\nadmin\n: adds Fulma with the \n'Admin'\n Bulma template.\n\n\ncover\n: adds Fulma with the \n'Cover'\n Bulma template.\n\n\nhero\n: adds Fulma with the \n'Hero'\n Bulma template.\n\n\nlanding\n: adds Fulma with the \n'Landing'\n Bulma template.\n\n\nlogin\n: adds Fulma with the \n'Login'\n Bulma template.\n\n\n\n\nFable.Remoting\n\n\nConfigures the SAFE app to use \nFable.Remoting\n to the template. See \nhere\n for an overview of Fable Remoting and the alternatives for sharing data between client and server.\n\n\nUsage: \ndotnet new SAFE --Remoting\n\n\nDocker\n\n\nConfigures the SAFE app to use a \nFAKE\n target that bundles and build a Docker image.\n\n\nUsage: \ndotnet new SAFE --Docker\n\n\nNPM\n\n\nConfigures the SAFE app to use NPM instead of default Yarn for JS package management.\n\n\nUsage: \ndotnet new SAFE --NPM\n\n\nExamples\n\n\n\n\nCreate a SAFE application using all defaults: \ndotnet new SAFE -lang F#\n\n\nCreate a SAFE application using Saturn with Fable Remoting: \ndotnet new SAFE -lang F# --Server saturn --Remoting\n\n\nCreate a SAFE application using Giraffe with Fulma: \ndotnet new SAFE -lang F# --Server giraffe --Fulma landing",
            "title": "The SAFE template"
        },
        {
            "location": "/safe-template/#using-the-template",
            "text": "Refer to the  Quick Start guide  to see basic guidance on how to use the template.",
            "title": "Using the template"
        },
        {
            "location": "/safe-template/#template-options",
            "text": "The template provides the ability to customise the created application. You can see template version and available options by running   dotnet new SAFE --help .",
            "title": "Template options"
        },
        {
            "location": "/safe-template/#server",
            "text": "Configures the SAFE app to use one of three different back-end hosting platforms.  Usage:  dotnet new SAFE --Server <server>  Where  <server>  is one of:   saturn : Creates a SAFE app running on Saturn on top of Giraffe  (recommended) .  giraffe : Creates a SAFE app running on Giraffe only.  suave : Creates a SAFE app running on Suave.",
            "title": "Server"
        },
        {
            "location": "/safe-template/#fulma",
            "text": "Configures the SAFE app to apply  Fulma  bindings to the UI template.  Usage:  dotnet new SAFE --Fulma <template>  Where  template  is one of:   none : don't add Fulma bindings at all  basic : adds Fulma basic template  admin : adds Fulma with the  'Admin'  Bulma template.  cover : adds Fulma with the  'Cover'  Bulma template.  hero : adds Fulma with the  'Hero'  Bulma template.  landing : adds Fulma with the  'Landing'  Bulma template.  login : adds Fulma with the  'Login'  Bulma template.",
            "title": "Fulma"
        },
        {
            "location": "/safe-template/#fableremoting",
            "text": "Configures the SAFE app to use  Fable.Remoting  to the template. See  here  for an overview of Fable Remoting and the alternatives for sharing data between client and server.  Usage:  dotnet new SAFE --Remoting",
            "title": "Fable.Remoting"
        },
        {
            "location": "/safe-template/#docker",
            "text": "Configures the SAFE app to use a  FAKE  target that bundles and build a Docker image.  Usage:  dotnet new SAFE --Docker",
            "title": "Docker"
        },
        {
            "location": "/safe-template/#npm",
            "text": "Configures the SAFE app to use NPM instead of default Yarn for JS package management.  Usage:  dotnet new SAFE --NPM",
            "title": "NPM"
        },
        {
            "location": "/safe-template/#examples",
            "text": "Create a SAFE application using all defaults:  dotnet new SAFE -lang F#  Create a SAFE application using Saturn with Fable Remoting:  dotnet new SAFE -lang F# --Server saturn --Remoting  Create a SAFE application using Giraffe with Fulma:  dotnet new SAFE -lang F# --Server giraffe --Fulma landing",
            "title": "Examples"
        },
        {
            "location": "/overview/",
            "text": "The SAFE acronym is made up of four separate components:\n\n\n\n\nS\naturn for back-end services in F#\n\n\nA\nzure as a hosting platform plus associated platform services\n\n\nF\nable for running F# in the web browser\n\n\nE\nlmish for client-side user interfaces\n\n\n\n\n\n\nSaturn\n\n\nThe \nGiraffe\n framework provides an F#-friendly, flexible pipeline for creating server-side web applications, built on top of ASP .NET Core - a high performance, rock-solid web server. The Saturn library builds on top of this solid foundation, and provides a set of \noptional\n abstractions which make configuring web applications and constructing complex routes extremely easy to achieve.\n\n\nBoth Saturn and Giraffe can host RESTful API endpoints, or drive static websites, or server-generated content, all inside an easy-to-learn functional programming model.\n\n\nMicrosoft Azure\n\n\nAzure is a comprehensive set of cloud services that developers and IT professionals use to build, deploy and manage applications through a global network of data centres. Integrated tools, DevOps and a marketplace support you in efficiently building anything from simple mobile apps to Internet-scale solutions.\n\n\nFable\n\n\nFable is an F# to JavaScript compiler powered by Babel, designed to produce readable and standard code. Fable allows you to create applications for the browser written entirely in F#, whilst also allowing you to interact with native Javascript as needed.\n\n\nElmish\n\n\nThe Elmish model allows you to construct user interfaces running in the browser using a functional programming model. Modelled on the Elm application model, Elmish uses the Model-View-Update paradigm to allow you to write applications that are simple to reason about. Elmish sits on top of the \nReact\n framework.\n\n\nAre there alternative components in the SAFE stack?\n\n\nYes, absolutely. The above components are what we recommended as the default SAFE stack, but you can of course replace the components with alternatives as you see fit. Here are some examples:\n\n\n\n\nSuave\n is a complete web server and programming model designed for F# that is similar to that of Giraffe.\n\n\nFreya\n is an alternative F#-first web stack which has a pluggable runtime model which allows it to be hosted in a variety of web servers including ASP .NET Core.\n\n\nAWS\n is Amazon's cloud compute offering, providing a large number of services available globally.\n\n\nWebSharper\n is a complete end-to-end programming stack, comprising both server- and client-side components. It supports both F# and C# programming models.",
            "title": "SAFE Stack Overview"
        },
        {
            "location": "/overview/#saturn",
            "text": "The  Giraffe  framework provides an F#-friendly, flexible pipeline for creating server-side web applications, built on top of ASP .NET Core - a high performance, rock-solid web server. The Saturn library builds on top of this solid foundation, and provides a set of  optional  abstractions which make configuring web applications and constructing complex routes extremely easy to achieve.  Both Saturn and Giraffe can host RESTful API endpoints, or drive static websites, or server-generated content, all inside an easy-to-learn functional programming model.",
            "title": "Saturn"
        },
        {
            "location": "/overview/#microsoft-azure",
            "text": "Azure is a comprehensive set of cloud services that developers and IT professionals use to build, deploy and manage applications through a global network of data centres. Integrated tools, DevOps and a marketplace support you in efficiently building anything from simple mobile apps to Internet-scale solutions.",
            "title": "Microsoft Azure"
        },
        {
            "location": "/overview/#fable",
            "text": "Fable is an F# to JavaScript compiler powered by Babel, designed to produce readable and standard code. Fable allows you to create applications for the browser written entirely in F#, whilst also allowing you to interact with native Javascript as needed.",
            "title": "Fable"
        },
        {
            "location": "/overview/#elmish",
            "text": "The Elmish model allows you to construct user interfaces running in the browser using a functional programming model. Modelled on the Elm application model, Elmish uses the Model-View-Update paradigm to allow you to write applications that are simple to reason about. Elmish sits on top of the  React  framework.",
            "title": "Elmish"
        },
        {
            "location": "/overview/#are-there-alternative-components-in-the-safe-stack",
            "text": "Yes, absolutely. The above components are what we recommended as the default SAFE stack, but you can of course replace the components with alternatives as you see fit. Here are some examples:   Suave  is a complete web server and programming model designed for F# that is similar to that of Giraffe.  Freya  is an alternative F#-first web stack which has a pluggable runtime model which allows it to be hosted in a variety of web servers including ASP .NET Core.  AWS  is Amazon's cloud compute offering, providing a large number of services available globally.  WebSharper  is a complete end-to-end programming stack, comprising both server- and client-side components. It supports both F# and C# programming models.",
            "title": "Are there alternative components in the SAFE stack?"
        },
        {
            "location": "/client-server/",
            "text": "One of SAFE's best features is the ability to share \ndata\n, \ntypes\n and \ncode\n across client and server. This page illustrates the different ways this can be achieved.\n\n\nSharing Types\n\n\nSharing your domain types and contracts between client and server is extremely simple. Thanks to Fable's excellent F# transpilation into Javascript, you can use all standard F# language features such as Records, Tuples and Discriminated Unions without worry. To share types across both your client and server project, first create a file in your repository called e.g \nShared.fs\n.\n\n\n\nThen, create types in the file as needed e.g\n\n\ntype Customer = { Name : string }\n\n\n\n\nReference this file to your server project. You can now reference those types in the server.\n\n\n<Project Sdk=\"Microsoft.NET.Sdk\">\n    ...\n    <ItemGroup>\n        <Compile Include=\"../Shared/Shared.fs\" />\n    </ItemGroup>\n    ...\n</Project>\n\n\n\n\nFinally, reference this file to your client project (as above). You can now reference those types in the client; types will be compiled into Javascript types and seamlessly translated for you.\n\n\nSharing Code\n\n\nYou can also share code using the same mechanism. This is extremely useful for e.g shared validation or business logic that needs to occur on both client and server.\n\n\nFable will translate your functions into native Javascript, and will even translate many calls to the .NET BCL into javascript! You can read more about this \non the Fable website\n.\n\n\nSharing Data\n\n\nSharing data can be achieved in two main ways in SAFE: through the \nSaturn\n API directly, or via the \nFable.Remoting\n library.\n\n\nSharing data with Saturn\n\n\nSharing data using Saturn is very simple. Start by creating a function in your server that returns some data:\n\n\nlet loadCustomersFromDb() =\n    [ { Name = \"Joe Bloggs\" } ]\n\n\n\n\nNext, create a method which returns the data as JSON within Giraffe's HTTP context.\n\n\n/// Returns the results of loadCustomersFromDb as JSON.\nlet getCustomers next ctx =\n    json (loadCustomersFromDb()) next ctx\n\n\n\n\nYou can opt to combine both of the above functions into one, depending on your preferences, but it's often good practice to separate your data access from serving data in HTTP endpoints.\n\n\nAlso note the \nnext\n and \nctx\n arguments. These are used by Giraffe as part of its \nHTTP pipeline\n and are required by the \njson\n function.\n\n\nNow expose the api method using \nSaturn's\n \nscope\n construct and add the scope to your overall application scope:\n\n\nlet myApis = scope {\n    get \"/api/customers/\" getCustomers\n}\n\n\n\n\nFor simple endpoints you may elect to embed the API call directly in the scope (and use partial application to omit the \nnext\n and \nctx\n arguments):\n\n\nlet myApis = scope {\n    get \"/api/customers/\" (json (loadCustomersFromDb()))\n}\n\n\n\n\nFinally, call the endpoint from your client application.\n\n\npromise {    \n    let! customers = Fetch.fetchAs<Customer array> (sprintf \"api/customers\") []\n    // do more with customers here...\n}\n\n\n\n\nNote the use of the \npromise { }\n computation expression. This functions like \nasync { }\n blocks that you already know, whilst the \nfetchAs\n function automatically deserializes the JSON back into a \nCustomer\n array.\n\n\nTurning on Fable's JSON Converter\n\n\nBy default, serialization between Fable and Giraffe \nis not compatible\n. In order to fix this, you must replace the JSON converter in Giraffe with Fable's own \nIJsonSerializer\n.\n\n\nIf you are using the dotnet SAFE Template, this will automatically be done for you - see the \nconfig\n function in \nServer.fs\n.\n\n\nSharing data using Fable.Remoting\n\n\nAs an alternative to raw HTTP, you can also use the \nFable.Remoting\n library, which provides an RPC-style mechanism for calling server endpoints.\n\n\nIn our case, instead of creating a \nscope { }\n on the server and using \nfetch\n on the client, you create a simple \nprotocol\n which contains methods exposed by the server:\n\n\ntype ICustomer = {\n    customers : unit -> Async<Customer array>\n}\n\nlet server : ICustomer = {\n    customers = fun () -> async { return loadCustomersFromDb() }\n}\n\n\n\n\nOn the client, you need only create a proxy for the protocol and then can call methods on it directly.\n\n\nasync {\n    let server = Proxy.remoting<ICustomer> {()}\n    let! customers = server.customers()\n    /// ...\n}\n\n\n\n\nNotice here, there is no need to create routes, or worry about HTTP verbs, or even involve yourself with the Giraffe pipeline.\n\n\nWhen should I use raw HTTP vs Fable Remoting?\n\n\nFable Remoting provides an excellent way to quickly get up and running with the SAFE stack. You can rapidly create contracts between client / server and have guaranteed contracts between both client and server. If you're using a \"closed\" app without exposing an API to other consumers, and do not need close control of the HTTP channel, consider using Fable.Remoting.\n\n\nThe raw HTTP model with \nscope { }\n requires you to construct routes manually and does not guarantee that the client and endpoint have the same contract (you have to specify it on both sides yourself), but gives you total control over the routing and verbs used. If you have a public API that is exposed not just to your own application but to third-parties, or you need more fine grained control over your routes and data, you should stick with this approach.",
            "title": "Client Server communication"
        },
        {
            "location": "/client-server/#sharing-types",
            "text": "Sharing your domain types and contracts between client and server is extremely simple. Thanks to Fable's excellent F# transpilation into Javascript, you can use all standard F# language features such as Records, Tuples and Discriminated Unions without worry. To share types across both your client and server project, first create a file in your repository called e.g  Shared.fs .  Then, create types in the file as needed e.g  type Customer = { Name : string }  Reference this file to your server project. You can now reference those types in the server.  <Project Sdk=\"Microsoft.NET.Sdk\">\n    ...\n    <ItemGroup>\n        <Compile Include=\"../Shared/Shared.fs\" />\n    </ItemGroup>\n    ...\n</Project>  Finally, reference this file to your client project (as above). You can now reference those types in the client; types will be compiled into Javascript types and seamlessly translated for you.",
            "title": "Sharing Types"
        },
        {
            "location": "/client-server/#sharing-code",
            "text": "You can also share code using the same mechanism. This is extremely useful for e.g shared validation or business logic that needs to occur on both client and server.  Fable will translate your functions into native Javascript, and will even translate many calls to the .NET BCL into javascript! You can read more about this  on the Fable website .",
            "title": "Sharing Code"
        },
        {
            "location": "/client-server/#sharing-data",
            "text": "Sharing data can be achieved in two main ways in SAFE: through the  Saturn  API directly, or via the  Fable.Remoting  library.",
            "title": "Sharing Data"
        },
        {
            "location": "/client-server/#sharing-data-with-saturn",
            "text": "Sharing data using Saturn is very simple. Start by creating a function in your server that returns some data:  let loadCustomersFromDb() =\n    [ { Name = \"Joe Bloggs\" } ]  Next, create a method which returns the data as JSON within Giraffe's HTTP context.  /// Returns the results of loadCustomersFromDb as JSON.\nlet getCustomers next ctx =\n    json (loadCustomersFromDb()) next ctx  You can opt to combine both of the above functions into one, depending on your preferences, but it's often good practice to separate your data access from serving data in HTTP endpoints.  Also note the  next  and  ctx  arguments. These are used by Giraffe as part of its  HTTP pipeline  and are required by the  json  function.  Now expose the api method using  Saturn's   scope  construct and add the scope to your overall application scope:  let myApis = scope {\n    get \"/api/customers/\" getCustomers\n}  For simple endpoints you may elect to embed the API call directly in the scope (and use partial application to omit the  next  and  ctx  arguments):  let myApis = scope {\n    get \"/api/customers/\" (json (loadCustomersFromDb()))\n}  Finally, call the endpoint from your client application.  promise {    \n    let! customers = Fetch.fetchAs<Customer array> (sprintf \"api/customers\") []\n    // do more with customers here...\n}  Note the use of the  promise { }  computation expression. This functions like  async { }  blocks that you already know, whilst the  fetchAs  function automatically deserializes the JSON back into a  Customer  array.",
            "title": "Sharing data with Saturn"
        },
        {
            "location": "/client-server/#turning-on-fables-json-converter",
            "text": "By default, serialization between Fable and Giraffe  is not compatible . In order to fix this, you must replace the JSON converter in Giraffe with Fable's own  IJsonSerializer .  If you are using the dotnet SAFE Template, this will automatically be done for you - see the  config  function in  Server.fs .",
            "title": "Turning on Fable's JSON Converter"
        },
        {
            "location": "/client-server/#sharing-data-using-fableremoting",
            "text": "As an alternative to raw HTTP, you can also use the  Fable.Remoting  library, which provides an RPC-style mechanism for calling server endpoints.  In our case, instead of creating a  scope { }  on the server and using  fetch  on the client, you create a simple  protocol  which contains methods exposed by the server:  type ICustomer = {\n    customers : unit -> Async<Customer array>\n}\n\nlet server : ICustomer = {\n    customers = fun () -> async { return loadCustomersFromDb() }\n}  On the client, you need only create a proxy for the protocol and then can call methods on it directly.  async {\n    let server = Proxy.remoting<ICustomer> {()}\n    let! customers = server.customers()\n    /// ...\n}  Notice here, there is no need to create routes, or worry about HTTP verbs, or even involve yourself with the Giraffe pipeline.",
            "title": "Sharing data using Fable.Remoting"
        },
        {
            "location": "/client-server/#when-should-i-use-raw-http-vs-fable-remoting",
            "text": "Fable Remoting provides an excellent way to quickly get up and running with the SAFE stack. You can rapidly create contracts between client / server and have guaranteed contracts between both client and server. If you're using a \"closed\" app without exposing an API to other consumers, and do not need close control of the HTTP channel, consider using Fable.Remoting.  The raw HTTP model with  scope { }  requires you to construct routes manually and does not guarantee that the client and endpoint have the same contract (you have to specify it on both sides yourself), but gives you total control over the routing and verbs used. If you have a public API that is exposed not just to your own application but to third-parties, or you need more fine grained control over your routes and data, you should stick with this approach.",
            "title": "When should I use raw HTTP vs Fable Remoting?"
        },
        {
            "location": "/learning/",
            "text": "This section contains useful repositories that allow you to learn more about the SAFE stack, at your own pace.\n\n\nTutorials\n\n\nSAFE Dojo\n\n\nThis dojo is a guided set of tasks designed to give you hands-on experience with the client and server components of the SAFE stack. You'll create server-side routes, client side UI and shared validation logic as you create a mashup application to provide details on UK locations.\n\n\nThe dojo takes around 90 minutes to complete if you have never worked with the stack before.\n\n\nSamples\n\n\nThe following example repositories (and more!) can be found in the official \nSAFE Stack\n organisational GitHub page.\n\n\nSAFE Bookstore\n\n\nThis sample demonstrates many of the useful features of a larger SAFE application, including login authentication using JWT tokens, automated deployment via Docker and SEO support with urls for pages. It also includes an example of using Azure Storage tables as a persistence store.\n\n\nSAFE ConfPlanner\n\n\nThis sample demonstrates how to build and share a complex domain model in SAFE across client and server, along with the use of websockets for a \"reactive\" UI support push notifications. It also demonstrates the use of F#'s flexible mailbox processors to implement an event-driven architecture.\n\n\nSAFE Search\n\n\nThis repository shows how to use Azure services to implement a SAFE application that supports searching over multiple data sources with support for find-ahead typing and throttling. The application uses a combination of Azure Search and Azure Storage Tables to construct a large search index that can rapidly find results in a number of ways.\n\n\nSAFE Chat\n\n\nThis application is a real-time chat application built on SAFE that uses the \nAKKA framework\n to manage actors that represent chat users, including Akka Streams and the Akkling F# library.\n\n\nSAFE Nightwatch\n\n\nThis application is a sample mobile application using the \nReact Native\n library, built on top of the SAFE stack. React Native permits a very similar programming when writing SAFE applications as browser applications, so the experience should be very familiar to you.",
            "title": "Learning Resources"
        },
        {
            "location": "/learning/#tutorials",
            "text": "",
            "title": "Tutorials"
        },
        {
            "location": "/learning/#safe-dojo",
            "text": "This dojo is a guided set of tasks designed to give you hands-on experience with the client and server components of the SAFE stack. You'll create server-side routes, client side UI and shared validation logic as you create a mashup application to provide details on UK locations.  The dojo takes around 90 minutes to complete if you have never worked with the stack before.",
            "title": "SAFE Dojo"
        },
        {
            "location": "/learning/#samples",
            "text": "The following example repositories (and more!) can be found in the official  SAFE Stack  organisational GitHub page.",
            "title": "Samples"
        },
        {
            "location": "/learning/#safe-bookstore",
            "text": "This sample demonstrates many of the useful features of a larger SAFE application, including login authentication using JWT tokens, automated deployment via Docker and SEO support with urls for pages. It also includes an example of using Azure Storage tables as a persistence store.",
            "title": "SAFE Bookstore"
        },
        {
            "location": "/learning/#safe-confplanner",
            "text": "This sample demonstrates how to build and share a complex domain model in SAFE across client and server, along with the use of websockets for a \"reactive\" UI support push notifications. It also demonstrates the use of F#'s flexible mailbox processors to implement an event-driven architecture.",
            "title": "SAFE ConfPlanner"
        },
        {
            "location": "/learning/#safe-search",
            "text": "This repository shows how to use Azure services to implement a SAFE application that supports searching over multiple data sources with support for find-ahead typing and throttling. The application uses a combination of Azure Search and Azure Storage Tables to construct a large search index that can rapidly find results in a number of ways.",
            "title": "SAFE Search"
        },
        {
            "location": "/learning/#safe-chat",
            "text": "This application is a real-time chat application built on SAFE that uses the  AKKA framework  to manage actors that represent chat users, including Akka Streams and the Akkling F# library.",
            "title": "SAFE Chat"
        },
        {
            "location": "/learning/#safe-nightwatch",
            "text": "This application is a sample mobile application using the  React Native  library, built on top of the SAFE stack. React Native permits a very similar programming when writing SAFE applications as browser applications, so the experience should be very familiar to you.",
            "title": "SAFE Nightwatch"
        },
        {
            "location": "/support/",
            "text": "The following companies provide commercial training, support, consultancy and development services for SAFE Stack applications.\n\n\nCompositional IT\n\n\n\n\nCompositional IT are experts in designing functional-first, cloud-ready systems, offering consultancy and support, training and development. Run by an F# MVP and well-known member of the .NET community, they are dedicated to raising awareness of the benefits of both functional programming and harnessing the power of the cloud to deliver high-quality, low-cost solutions.\n\n\nLambda Factory\n\n\n\n\nLambda Factory is a consulting company specializing in designing and building complex systems using Functional Programming languages such as F#, Elm and Elixir. It also offers help with introducing functional programming and open source driven development to the organization, as well as trainings, workshops and mentoring. Founded by open source contributor and well-known member of F# Community, Lambda Factory has been committed to supporting F# Community and helping it grow.\n\n\nThe F# Community\n\n\nThe SAFE stack was written largely by the community as open source projects, such as Saturn, Giraffe, Fable and Elmish (as well as the alternative elements within the stack). All those teams are always happy to contribute and help out.\n\n\nSocial\n\n\nYou can also reach out to the SAFE team on \n@safe_stack\n or on the regular F# channels on Slack: either the official \nF# Foundation Slack\n or on the \nFunctional Programming Slack\n. We'll be expanding this over time.",
            "title": "Support"
        },
        {
            "location": "/support/#compositional-it",
            "text": "Compositional IT are experts in designing functional-first, cloud-ready systems, offering consultancy and support, training and development. Run by an F# MVP and well-known member of the .NET community, they are dedicated to raising awareness of the benefits of both functional programming and harnessing the power of the cloud to deliver high-quality, low-cost solutions.",
            "title": "Compositional IT"
        },
        {
            "location": "/support/#lambda-factory",
            "text": "Lambda Factory is a consulting company specializing in designing and building complex systems using Functional Programming languages such as F#, Elm and Elixir. It also offers help with introducing functional programming and open source driven development to the organization, as well as trainings, workshops and mentoring. Founded by open source contributor and well-known member of F# Community, Lambda Factory has been committed to supporting F# Community and helping it grow.",
            "title": "Lambda Factory"
        },
        {
            "location": "/support/#the-f-community",
            "text": "The SAFE stack was written largely by the community as open source projects, such as Saturn, Giraffe, Fable and Elmish (as well as the alternative elements within the stack). All those teams are always happy to contribute and help out.",
            "title": "The F# Community"
        },
        {
            "location": "/support/#social",
            "text": "You can also reach out to the SAFE team on  @safe_stack  or on the regular F# channels on Slack: either the official  F# Foundation Slack  or on the  Functional Programming Slack . We'll be expanding this over time.",
            "title": "Social"
        },
        {
            "location": "/testimonials/",
            "text": "Please feel free to submit a PR to add testimonials to this page!",
            "title": "Testimonials"
        }
    ]
}
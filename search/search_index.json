{
    "docs": [
        {
            "location": "/",
            "text": "Welcome to the SAFE documentation site! This site contains all the documentation you'll need to quickly starting creating SAFE apps in F#. If you've not heard of SAFE before, please feel free to start with the \nintroduction\n. Alternatively, you can immediately try out the \nquick start\n guide and tutorial, or simply browse through the documentation.\n\n\nIf there's anything missing from here, please feel free to add the documentation directly (or supply an issue) to the \nGitHub repository\n.\n\n\nWe hope you enjoy using SAFE as much as we do!\n\n\nThe SAFE team.",
            "title": "Home"
        },
        {
            "location": "/intro/",
            "text": "What is SAFE?\n\n\nThe SAFE stack is an \nopen-source, free, flexible\n end-to-end, \nfunctional-first\n stack for \ncloud-ready web applications\n that emphasizes \ntype-safe programming\n.\n\n\nThe SAFE stack allows you to \ndevelop web applications\n almost entirely in \nF#\n, without needing to compromise and shoehorn your codebase into an object-oriented framework or library, and without needing you to be an expert in CSS or HTML to create compelling, rich client-side web applications.\n\n\nThe SAFE stack is made up of four components:\n\n\n\n\nA \nweb server\n running on .NET Core for hosting back-end services in F#\n\n\nA \nhosting platform\n that provides simple, scalable deployment models plus associated platform services for application developers\n\n\nA mechanism to run F# in the web browser for \nclient-side delivery of F#\n\n\nAn F# programming model for \nclient-side user interfaces\n\n\n\n\nWhy SAFE?\n\n\nSAFE provides developers with a simple and consistent programming model for developing rich, scalable web-enabled applications that can run on multiple platforms. SAFE takes advantage of F#'s mix of a functional-first experience backed by the powerful and mature .NET framework to provide a type-safe, reliable experience that leads to the \"pit of success\".\n\n\n\n\nCreate client / server applications entirely in F#\n\n\nRe-use development skills on client and server\n\n\nRapidly create rich client-side web applications with no Javascript knowledge\n\n\nRuns on the latest .NET Core (and tested daily by Microsoft)\n\n\nRapid development cycle with support for \nhot module replacement\n\n\nInteract with native Javascript libraries whenever needed\n\n\nCreate client-side applications purely in F#, with full type checking for safety\n\n\nSeamlessly share code between client and server",
            "title": "Introduction"
        },
        {
            "location": "/intro/#what-is-safe",
            "text": "The SAFE stack is an  open-source, free, flexible  end-to-end,  functional-first  stack for  cloud-ready web applications  that emphasizes  type-safe programming .  The SAFE stack allows you to  develop web applications  almost entirely in  F# , without needing to compromise and shoehorn your codebase into an object-oriented framework or library, and without needing you to be an expert in CSS or HTML to create compelling, rich client-side web applications.  The SAFE stack is made up of four components:   A  web server  running on .NET Core for hosting back-end services in F#  A  hosting platform  that provides simple, scalable deployment models plus associated platform services for application developers  A mechanism to run F# in the web browser for  client-side delivery of F#  An F# programming model for  client-side user interfaces",
            "title": "What is SAFE?"
        },
        {
            "location": "/intro/#why-safe",
            "text": "SAFE provides developers with a simple and consistent programming model for developing rich, scalable web-enabled applications that can run on multiple platforms. SAFE takes advantage of F#'s mix of a functional-first experience backed by the powerful and mature .NET framework to provide a type-safe, reliable experience that leads to the \"pit of success\".   Create client / server applications entirely in F#  Re-use development skills on client and server  Rapidly create rich client-side web applications with no Javascript knowledge  Runs on the latest .NET Core (and tested daily by Microsoft)  Rapid development cycle with support for  hot module replacement  Interact with native Javascript libraries whenever needed  Create client-side applications purely in F#, with full type checking for safety  Seamlessly share code between client and server",
            "title": "Why SAFE?"
        },
        {
            "location": "/quickstart/",
            "text": "This page provides some basic guidance on getting up and running with your first SAFE application.\n\n\nInstall pre-requisites\n\n\nYou'll need to install the following pre-requisites in order to build SAFE applications\n\n\n\n\nThe \n.NET Core SDK 2.x\n.\n\n\nThe \nYarn\n package manager.\n\n\nNode 8.x\n installed for the front end components.\n\n\nIf you're running on OSX or Linux, you'll also need to install \nMono\n.\n\n\n\n\nInstall an F# code editor\n\n\nYou'll also want an IDE to create F# applications. We recommend one of the following great IDEs.\n\n\n\n\nVS Code\n + \nIonide\n extension\n\n\nVisual Studio 2017\n\n\nJetbrains Rider\n\n\n\n\nCreate your first SAFE app\n\n\n\n\nCreate a new directory on your machine\n\n\nOpen a command prompt\n\n\nEnter \ndotnet new -i SAFE.Template\n to install the \nSAFE project template\n\n\nEnter \ndotnet new SAFE -lang F#\n to create a new SAFE project\n\n\nEnter \nbuild.cmd run\n (Windows) or \n./build.sh run\n (Linux / OSX)\n\n\n\n\nCongratulations! After a short delay, you'll be presented with a basic SAFE application running in your browser! The app will by default run in \"development mode\", which means it automatically watches your project for changes. Whenever you save a file in the client project it will refresh the browser \nautomatically\n; if you save a file in the server project it will restart the server in the background.\n\n\nTip: Take a look at the \ntemplate options\n. There are several ways to customise the default application, including server technology and client/server communication technology.",
            "title": "Quick Start"
        },
        {
            "location": "/quickstart/#install-pre-requisites",
            "text": "You'll need to install the following pre-requisites in order to build SAFE applications   The  .NET Core SDK 2.x .  The  Yarn  package manager.  Node 8.x  installed for the front end components.  If you're running on OSX or Linux, you'll also need to install  Mono .",
            "title": "Install pre-requisites"
        },
        {
            "location": "/quickstart/#install-an-f-code-editor",
            "text": "You'll also want an IDE to create F# applications. We recommend one of the following great IDEs.   VS Code  +  Ionide  extension  Visual Studio 2017  Jetbrains Rider",
            "title": "Install an F# code editor"
        },
        {
            "location": "/quickstart/#create-your-first-safe-app",
            "text": "Create a new directory on your machine  Open a command prompt  Enter  dotnet new -i SAFE.Template  to install the  SAFE project template  Enter  dotnet new SAFE -lang F#  to create a new SAFE project  Enter  build.cmd run  (Windows) or  ./build.sh run  (Linux / OSX)   Congratulations! After a short delay, you'll be presented with a basic SAFE application running in your browser! The app will by default run in \"development mode\", which means it automatically watches your project for changes. Whenever you save a file in the client project it will refresh the browser  automatically ; if you save a file in the server project it will restart the server in the background.  Tip: Take a look at the  template options . There are several ways to customise the default application, including server technology and client/server communication technology.",
            "title": "Create your first SAFE app"
        },
        {
            "location": "/safe-template/",
            "text": "The \nSAFE Template\n is a \ndotnet CLI template\n for SAFE Stack projects, designed to get you up and running as quickly as possible, with flexible options to suit your application.\n\n\nThe template gets you up and running with 3 core components of the stack:\n\n\n\n\nSaturn\n, \nGiraffe\n or \nSuave\n\n\nFable\n\n\nElmish\n\n\n\n\nCurrently, the template does not include any Azure / other Cloud integration except Docker deployment. Refer to the \nSAFE-Bookstore\n repository for an example that uses Azure Table Storage. We're working on improving this to include standard Azure dependencies and other deployment mechanisms.\n\n\nUsing the template\n\n\nRefer to the \nQuick Start guide\n to see basic guidance on how to install and use the template.\n\n\nTemplate options\n\n\nThe template provides the ability to customise the created application. You can see template version and available options by running  \ndotnet new SAFE --help\n.\n\n\nServer\n\n\nConfigures the SAFE app to use one of three different back-end hosting platforms.\n\n\nUsage: \ndotnet new SAFE --Server <server>\n\n\nWhere \n<server>\n is one of:\n\n\n\n\nsaturn\n: Creates a SAFE app running on Saturn on top of Giraffe \n(default)\n.\n\n\ngiraffe\n: Creates a SAFE app running on Giraffe only.\n\n\nsuave\n: Creates a SAFE app running on Suave.\n\n\n\n\nFulma\n\n\nConfigures the SAFE app to apply \nFulma\n bindings to the UI template.\n\n\nUsage: \ndotnet new SAFE --Fulma <template>\n\n\nWhere \n<template>\n is one of:\n\n\n\n\nnone\n: don't add Fulma bindings at all \n(default)\n.\n\n\nbasic\n: adds Fulma basic template.\n\n\nadmin\n: adds Fulma with the \n'Admin'\n Bulma template.\n\n\ncover\n: adds Fulma with the \n'Cover'\n Bulma template.\n\n\nhero\n: adds Fulma with the \n'Hero'\n Bulma template.\n\n\nlanding\n: adds Fulma with the \n'Landing'\n Bulma template.\n\n\nlogin\n: adds Fulma with the \n'Login'\n Bulma template.\n\n\n\n\nFable.Remoting\n\n\nConfigures the SAFE app to use \nFable.Remoting\n to the template. See \nhere\n for an overview of Fable Remoting and the alternatives for sharing data between client and server.\n\n\nUsage: \ndotnet new SAFE --Remoting\n\n\nDocker\n\n\nConfigures the SAFE app to use a \nFAKE\n target that bundles and build a Docker image.\n\n\nUsage: \ndotnet new SAFE --Docker\n\n\nNPM\n\n\nConfigures the SAFE app to use NPM instead of default Yarn for JS package management.\n\n\nUsage: \ndotnet new SAFE --NPM\n\n\nExamples\n\n\n\n\nCreate a SAFE application using all defaults: \ndotnet new SAFE -lang F#\n\n\nCreate a SAFE application using giraffe with Fable Remoting: \ndotnet new SAFE -lang F# --Server giraffe --Remoting\n\n\nCreate a SAFE application using Suave with Fulma: \ndotnet new SAFE -lang F# --Server suave --Fulma landing",
            "title": "The SAFE template"
        },
        {
            "location": "/safe-template/#using-the-template",
            "text": "Refer to the  Quick Start guide  to see basic guidance on how to install and use the template.",
            "title": "Using the template"
        },
        {
            "location": "/safe-template/#template-options",
            "text": "The template provides the ability to customise the created application. You can see template version and available options by running   dotnet new SAFE --help .",
            "title": "Template options"
        },
        {
            "location": "/safe-template/#server",
            "text": "Configures the SAFE app to use one of three different back-end hosting platforms.  Usage:  dotnet new SAFE --Server <server>  Where  <server>  is one of:   saturn : Creates a SAFE app running on Saturn on top of Giraffe  (default) .  giraffe : Creates a SAFE app running on Giraffe only.  suave : Creates a SAFE app running on Suave.",
            "title": "Server"
        },
        {
            "location": "/safe-template/#fulma",
            "text": "Configures the SAFE app to apply  Fulma  bindings to the UI template.  Usage:  dotnet new SAFE --Fulma <template>  Where  <template>  is one of:   none : don't add Fulma bindings at all  (default) .  basic : adds Fulma basic template.  admin : adds Fulma with the  'Admin'  Bulma template.  cover : adds Fulma with the  'Cover'  Bulma template.  hero : adds Fulma with the  'Hero'  Bulma template.  landing : adds Fulma with the  'Landing'  Bulma template.  login : adds Fulma with the  'Login'  Bulma template.",
            "title": "Fulma"
        },
        {
            "location": "/safe-template/#fableremoting",
            "text": "Configures the SAFE app to use  Fable.Remoting  to the template. See  here  for an overview of Fable Remoting and the alternatives for sharing data between client and server.  Usage:  dotnet new SAFE --Remoting",
            "title": "Fable.Remoting"
        },
        {
            "location": "/safe-template/#docker",
            "text": "Configures the SAFE app to use a  FAKE  target that bundles and build a Docker image.  Usage:  dotnet new SAFE --Docker",
            "title": "Docker"
        },
        {
            "location": "/safe-template/#npm",
            "text": "Configures the SAFE app to use NPM instead of default Yarn for JS package management.  Usage:  dotnet new SAFE --NPM",
            "title": "NPM"
        },
        {
            "location": "/safe-template/#examples",
            "text": "Create a SAFE application using all defaults:  dotnet new SAFE -lang F#  Create a SAFE application using giraffe with Fable Remoting:  dotnet new SAFE -lang F# --Server giraffe --Remoting  Create a SAFE application using Suave with Fulma:  dotnet new SAFE -lang F# --Server suave --Fulma landing",
            "title": "Examples"
        },
        {
            "location": "/overview/",
            "text": "SAFE Stack components\n\n\nThe SAFE acronym is made up of four separate components:\n\n\n\n\nS\naturn\n for back-end services in F#\n\n\nA\nzure\n as a hosting platform plus associated platform services\n\n\nF\nable\n for running F# in the web browser\n\n\nE\nlmish\n for client-side user interfaces\n\n\n\n\n\n\nSaturn\n\n\nThe Saturn library builds on top of the solid foundation of both the F#-friendly \nGiraffe\n and the high performance, rock-solid \nASP .NET Core\n web server to provide a set of optional abstractions which make configuring web applications and constructing complex routes extremely easy to achieve.\n\n\nSaturn can host RESTful API endpoints, drive static websites or server-generated content, all inside an easy-to-learn functional programming model.\n\n\nMicrosoft Azure\n\n\nAzure is a comprehensive set of cloud services that developers and IT professionals use to build, deploy and manage applications through a global network of data centres. Integrated tools, DevOps and a marketplace support you in efficiently building anything from simple mobile apps to Internet-scale solutions.\n\n\nFable\n\n\nFable is an F# to JavaScript compiler powered by Babel, designed to produce readable and standard code. Fable allows you to create applications for the browser written entirely in F#, whilst also allowing you to interact with native Javascript as needed.\n\n\nElmish\n\n\nThe Elmish model allows you to construct user interfaces running in the browser using a functional programming model. Modelled on the Elm application model, Elmish uses the Model-View-Update paradigm to allow you to write applications that are simple to reason about. Elmish sits on top of the \nReact\n framework.\n\n\nFurther reading\n\n\nPlease also feel free to read this \nblog series\n on the Compositional IT website for more details on the history of SAFE.\n\n\nAre there alternative components in the SAFE stack?\n\n\nYes, absolutely. The above components are what we recommended as the default SAFE stack, but you can of course replace the components with alternatives as you see fit. Here are some examples:\n\n\n\n\nGiraffe\n is a programming model designed for F# that runs on ASP .NET Core. As Saturn runs on top of Giraffe, you automatically get full access to it, but nonetheless it is entirely possible to write applications solely in Giraffe.\n\n\nSuave\n is a complete web server and programming model designed for F# that is similar to that of Giraffe.\n\n\nFreya\n is an alternative F#-first web stack which has a pluggable runtime model which allows it to be hosted in a variety of web servers including ASP .NET Core.\n\n\nAWS\n is Amazon's cloud compute offering, providing a large number of services available globally.\n\n\nWebSharper\n is a complete end-to-end programming stack, comprising both server- and client-side components. It supports both F# and C# programming models.",
            "title": "SAFE Stack Overview"
        },
        {
            "location": "/overview/#safe-stack-components",
            "text": "The SAFE acronym is made up of four separate components:   S aturn  for back-end services in F#  A zure  as a hosting platform plus associated platform services  F able  for running F# in the web browser  E lmish  for client-side user interfaces",
            "title": "SAFE Stack components"
        },
        {
            "location": "/overview/#saturn",
            "text": "The Saturn library builds on top of the solid foundation of both the F#-friendly  Giraffe  and the high performance, rock-solid  ASP .NET Core  web server to provide a set of optional abstractions which make configuring web applications and constructing complex routes extremely easy to achieve.  Saturn can host RESTful API endpoints, drive static websites or server-generated content, all inside an easy-to-learn functional programming model.",
            "title": "Saturn"
        },
        {
            "location": "/overview/#microsoft-azure",
            "text": "Azure is a comprehensive set of cloud services that developers and IT professionals use to build, deploy and manage applications through a global network of data centres. Integrated tools, DevOps and a marketplace support you in efficiently building anything from simple mobile apps to Internet-scale solutions.",
            "title": "Microsoft Azure"
        },
        {
            "location": "/overview/#fable",
            "text": "Fable is an F# to JavaScript compiler powered by Babel, designed to produce readable and standard code. Fable allows you to create applications for the browser written entirely in F#, whilst also allowing you to interact with native Javascript as needed.",
            "title": "Fable"
        },
        {
            "location": "/overview/#elmish",
            "text": "The Elmish model allows you to construct user interfaces running in the browser using a functional programming model. Modelled on the Elm application model, Elmish uses the Model-View-Update paradigm to allow you to write applications that are simple to reason about. Elmish sits on top of the  React  framework.",
            "title": "Elmish"
        },
        {
            "location": "/overview/#further-reading",
            "text": "Please also feel free to read this  blog series  on the Compositional IT website for more details on the history of SAFE.",
            "title": "Further reading"
        },
        {
            "location": "/overview/#are-there-alternative-components-in-the-safe-stack",
            "text": "Yes, absolutely. The above components are what we recommended as the default SAFE stack, but you can of course replace the components with alternatives as you see fit. Here are some examples:   Giraffe  is a programming model designed for F# that runs on ASP .NET Core. As Saturn runs on top of Giraffe, you automatically get full access to it, but nonetheless it is entirely possible to write applications solely in Giraffe.  Suave  is a complete web server and programming model designed for F# that is similar to that of Giraffe.  Freya  is an alternative F#-first web stack which has a pluggable runtime model which allows it to be hosted in a variety of web servers including ASP .NET Core.  AWS  is Amazon's cloud compute offering, providing a large number of services available globally.  WebSharper  is a complete end-to-end programming stack, comprising both server- and client-side components. It supports both F# and C# programming models.",
            "title": "Are there alternative components in the SAFE stack?"
        },
        {
            "location": "/safe-saturn/",
            "text": "Saturn\n in SAFE\n\n\nSaturn is a web development library written in F# which allows you to easily create both server-side MVC applications as well as web APIs. It runs on top of two other components:\n\n\n\n\nGiraffe\n, an F#-specific library for writing functional-first web applications.\n\n\nMicrosoft's \nASP.NET Core\n.\n\n\n\n\nSaturn, via Giraffe, provides very good integration with other ASP.NET Core components such as authentication.\n\n\nMany of Saturn's components and concepts will seem familiar to those of us with experience of other web frameworks such as Ruby on Rails, Python\u2019s Django or especially Elixir's \nPhoenix\n.\n\n\nHow does Saturn integrate with SAFE?\n\n\nSaturn provides the ability to drive your SAFE applications from the server. It enables:\n\n\n\n\nRouting and hosting of your server-side APIs through a set of simple-to-use abstractions.\n\n\nHosting of your client-side assets, such as HTML, CSS and JavaScript generated by Fable.\n\n\nOther cross cutting concerns e.g. authentication etc.\n\n\n\n\nIt also integrates with SAFE to allow seamless sharing of types and functions, since Fable will convert most F# into JavaScript. In addition, you can seamless transport data between client and server using either the Fable.JSON or Fable.Remoting libraries, both of which have support for Saturn. You can read more about this \nhere\n.\n\n\n\n\nLearn more about Saturn \nhere\n.",
            "title": "Learn about Saturn"
        },
        {
            "location": "/safe-saturn/#saturn-in-safe",
            "text": "Saturn is a web development library written in F# which allows you to easily create both server-side MVC applications as well as web APIs. It runs on top of two other components:   Giraffe , an F#-specific library for writing functional-first web applications.  Microsoft's  ASP.NET Core .   Saturn, via Giraffe, provides very good integration with other ASP.NET Core components such as authentication.  Many of Saturn's components and concepts will seem familiar to those of us with experience of other web frameworks such as Ruby on Rails, Python\u2019s Django or especially Elixir's  Phoenix .",
            "title": "Saturn in SAFE"
        },
        {
            "location": "/safe-saturn/#how-does-saturn-integrate-with-safe",
            "text": "Saturn provides the ability to drive your SAFE applications from the server. It enables:   Routing and hosting of your server-side APIs through a set of simple-to-use abstractions.  Hosting of your client-side assets, such as HTML, CSS and JavaScript generated by Fable.  Other cross cutting concerns e.g. authentication etc.   It also integrates with SAFE to allow seamless sharing of types and functions, since Fable will convert most F# into JavaScript. In addition, you can seamless transport data between client and server using either the Fable.JSON or Fable.Remoting libraries, both of which have support for Saturn. You can read more about this  here .   Learn more about Saturn  here .",
            "title": "How does Saturn integrate with SAFE?"
        },
        {
            "location": "/safe-azure/",
            "text": "Azure\n in SAFE\n\n\nWhat is Azure?\n\n\nAzure is a comprehensive set of cloud services that developers and IT professionals use to build, deploy and manage applications through a global network of data centres. Integrated tools, DevOps and a marketplace support you in efficiently building anything from simple mobile apps to Internet-scale solutions.\n\n\nHow does Azure integrate with SAFE?\n\n\nAzure provides a number of flexible services for SAFE applications, including (but not only):\n\n\nHosting Services\n\n\nAzure comes with several ready-made hosting services, including App Service, which enables seamless hosting of web applications, including ASP .NET Core applications (which \nSaturn\n is built on top of). In addition, Azure supports a number of managed \nhosting services\n for \nDocker\n and \nKubernetes\n, which work fantastically well with SAFE.\n\n\nPlatform Services\n\n\nAzure comes with a large number of ready-made platform services that can \ndramatically lower the cost\n of developing bespoke systems, including:\n\n\n\n\nCompute\n services such as \nAzure Functions\n, for hosting F# code that can dynamically scale based on load, as well as \nService Fabric\n or \nVirtual Machines\n.\n\n\nStorage\n services such as \nAzure Storage\n and \nData Lake\n, for storing virtually limitless volumes of data in unstructured or structure form.\n\n\nDatabase\n services, including managed \nSQL Server\n, \nMySQL\n and \nPostgres\n, as well as \nCosmosDB\n for document and graph stores, \nRedis\n and more.\n\n\nMessaging\n services including \nQueues\n, \nService Bus\n and \nEvent Hub\n.\n\n\nAnalytical\n services such as \nStream Analytics\n, \nDatabricks\n, \nMachine Learning\n and \nAnalysis Services\n.\n\n\nSecurity\n services such as \nKey Vault\n and \nActive Directory\n.\n\n\n\n\nMany of the above services have ready-made SDKs that can be run on .NET and therefore from F#. In addition, the \nAzure Storage Type Provider\n provides unparallel ease of access to Azure Storage Blobs, Queues and Tables from F# \n(currently not yet supported on .NET Core)\n.",
            "title": "Learn about Azure"
        },
        {
            "location": "/safe-azure/#azure-in-safe",
            "text": "",
            "title": "Azure in SAFE"
        },
        {
            "location": "/safe-azure/#what-is-azure",
            "text": "Azure is a comprehensive set of cloud services that developers and IT professionals use to build, deploy and manage applications through a global network of data centres. Integrated tools, DevOps and a marketplace support you in efficiently building anything from simple mobile apps to Internet-scale solutions.",
            "title": "What is Azure?"
        },
        {
            "location": "/safe-azure/#how-does-azure-integrate-with-safe",
            "text": "Azure provides a number of flexible services for SAFE applications, including (but not only):",
            "title": "How does Azure integrate with SAFE?"
        },
        {
            "location": "/safe-azure/#hosting-services",
            "text": "Azure comes with several ready-made hosting services, including App Service, which enables seamless hosting of web applications, including ASP .NET Core applications (which  Saturn  is built on top of). In addition, Azure supports a number of managed  hosting services  for  Docker  and  Kubernetes , which work fantastically well with SAFE.",
            "title": "Hosting Services"
        },
        {
            "location": "/safe-azure/#platform-services",
            "text": "Azure comes with a large number of ready-made platform services that can  dramatically lower the cost  of developing bespoke systems, including:   Compute  services such as  Azure Functions , for hosting F# code that can dynamically scale based on load, as well as  Service Fabric  or  Virtual Machines .  Storage  services such as  Azure Storage  and  Data Lake , for storing virtually limitless volumes of data in unstructured or structure form.  Database  services, including managed  SQL Server ,  MySQL  and  Postgres , as well as  CosmosDB  for document and graph stores,  Redis  and more.  Messaging  services including  Queues ,  Service Bus  and  Event Hub .  Analytical  services such as  Stream Analytics ,  Databricks ,  Machine Learning  and  Analysis Services .  Security  services such as  Key Vault  and  Active Directory .   Many of the above services have ready-made SDKs that can be run on .NET and therefore from F#. In addition, the  Azure Storage Type Provider  provides unparallel ease of access to Azure Storage Blobs, Queues and Tables from F#  (currently not yet supported on .NET Core) .",
            "title": "Platform Services"
        },
        {
            "location": "/safe-fable/",
            "text": "Fable\n in SAFE\n\n\nFable is an F# to JavaScript compiler powered by \nBabel\n, designed to produce readable and standard JavaScript code.    \n\n\nFable brings all the power of F# to the JavaScript ecosystem, it supports most of the F# core library and some of the most commonly used .NET APIs\n\n\nLearn more about Fable \nhere",
            "title": "Learn about Fable"
        },
        {
            "location": "/safe-fable/#fable-in-safe",
            "text": "Fable is an F# to JavaScript compiler powered by  Babel , designed to produce readable and standard JavaScript code.      Fable brings all the power of F# to the JavaScript ecosystem, it supports most of the F# core library and some of the most commonly used .NET APIs  Learn more about Fable  here",
            "title": "Fable in SAFE"
        },
        {
            "location": "/safe-elmish/",
            "text": "Elmish\n in SAFE\n\n\nWhat is Elmish?\n\n\nElmish is a set of simple abstractions for writing user interfaces in F# applications in a functional style following the \nmodel-view-update\n architecture made famous by \nElm\n. The Elmish library is not coupled to any specific view engine, but is intended for use in conjuction with a DOM/renderer such as React/ReactNative or VirtualDOM.\n\n\nHow does Elmish integrate with SAFE?\n\n\nElmish provides the ability to more easily create user interfaces in the browser on top of \nFable\n so that you don't have to write applications that are tightly coupled to HTML using e.g. JQuery or similar. The \nSAFE Stack templates\n comes pre-bundled with the \nElmish React\n module, which (as the name suggests) uses the \nReact\n library to handle the heavy lifting of modifyng the DOM in an efficient way. This allow us to use the pure functional style of the MVU pattern whilst still retaining the ability to have a highly performant user interface.\n\n\nThis conceptual diagram illustrates how your F# is run in the browser in a SAFE app.\n\n\n\n\nLearn more about Elmish \nhere\n.",
            "title": "Learn about Elmish"
        },
        {
            "location": "/safe-elmish/#elmish-in-safe",
            "text": "",
            "title": "Elmish in SAFE"
        },
        {
            "location": "/safe-elmish/#what-is-elmish",
            "text": "Elmish is a set of simple abstractions for writing user interfaces in F# applications in a functional style following the  model-view-update  architecture made famous by  Elm . The Elmish library is not coupled to any specific view engine, but is intended for use in conjuction with a DOM/renderer such as React/ReactNative or VirtualDOM.",
            "title": "What is Elmish?"
        },
        {
            "location": "/safe-elmish/#how-does-elmish-integrate-with-safe",
            "text": "Elmish provides the ability to more easily create user interfaces in the browser on top of  Fable  so that you don't have to write applications that are tightly coupled to HTML using e.g. JQuery or similar. The  SAFE Stack templates  comes pre-bundled with the  Elmish React  module, which (as the name suggests) uses the  React  library to handle the heavy lifting of modifyng the DOM in an efficient way. This allow us to use the pure functional style of the MVU pattern whilst still retaining the ability to have a highly performant user interface.  This conceptual diagram illustrates how your F# is run in the browser in a SAFE app.   Learn more about Elmish  here .",
            "title": "How does Elmish integrate with SAFE?"
        },
        {
            "location": "/safe-server/",
            "text": "Server-side options in SAFE\n\n\nThe \nSAFE template\n comes with three alternative server technologies out of the box:\n\n\n\n\nSaturn\n - A simple, flexible F# abstraction layer that runs on top of Giraffe that enables both MVC- and Web API-style services. \n\n\nGiraffe\n - A flexible F# framework for creating web-enabled applications. Giraffe runs on top of ASP .NET Core and the Kestrel server. Giraffe's programming model is itself based on Suave's programming model, but has some differences.\n\n\nSuave\n - A flexible F# framework for creating web-enabled applications. Suave comes with its own built-in web server.\n\n\n\n\nComparing servers\n\n\nThe diagram below illustrates some of the differences and similarities of the three stacks.\n\n\n\n\nThis is also shown in the table below. The core abstractions of Giraffe and Suave - the HTTP Handler and WebPart - are effectively the same thing. Saturn, which lives \"on top\" of Giraffe, provides a set of new, higher-level abstractions which delegate down to Giraffe's HTTP Handler.\n\n\n\n\n\n\n\n\n\n\nSaturn\n\n\nGiraffe\n\n\nSuave\n\n\n\n\n\n\n\n\n\n\nASP .NET compatible?\n\n\nYes\n\n\nYes\n\n\nNo\n\n\n\n\n\n\nF#-first\n\n\nYes\n\n\nYes\n\n\nYes\n\n\n\n\n\n\nCore Abstractions\n\n\nscope { } and controller { }\n\n\nHttpHandler\n\n\nWebPart\n\n\n\n\n\n\n\n\nWhy Saturn?\n\n\n Saturn is the default and recommended web server in SAFE\n.\n\n\nSaturn (and Giraffe) runs on top of ASP .NET Core, which comes with an extremely high-performance server that is fully supported by Microsoft, has a huge community of developers and has excellent integration into cloud services such as Microsoft Azure and Amazon Web Services.\n\n\nIn addition, whilst the Giraffe and the Suave programming are extremely composable and fully functional-first, Saturn allows you to take advantage of abstractions such as \napplication { }\n, \nscope { }\n and \ncontroller { }\n which are not only extremely simple to use but will also be familiar to developers from other (non-.NET) web programming models. And since Saturn's abstractions are all \noptional\n, you can always fall back directly to the lower-level Giraffe model if required.\n\n\nYou'll probably find more samples online that use Suave at the time of writing. However, since Giraffe's programming model is similar to that of Suave, porting them across to Saturn / Giraffe is relatively easy to do.",
            "title": "Choosing your web server"
        },
        {
            "location": "/safe-server/#server-side-options-in-safe",
            "text": "The  SAFE template  comes with three alternative server technologies out of the box:   Saturn  - A simple, flexible F# abstraction layer that runs on top of Giraffe that enables both MVC- and Web API-style services.   Giraffe  - A flexible F# framework for creating web-enabled applications. Giraffe runs on top of ASP .NET Core and the Kestrel server. Giraffe's programming model is itself based on Suave's programming model, but has some differences.  Suave  - A flexible F# framework for creating web-enabled applications. Suave comes with its own built-in web server.",
            "title": "Server-side options in SAFE"
        },
        {
            "location": "/safe-server/#comparing-servers",
            "text": "The diagram below illustrates some of the differences and similarities of the three stacks.   This is also shown in the table below. The core abstractions of Giraffe and Suave - the HTTP Handler and WebPart - are effectively the same thing. Saturn, which lives \"on top\" of Giraffe, provides a set of new, higher-level abstractions which delegate down to Giraffe's HTTP Handler.      Saturn  Giraffe  Suave      ASP .NET compatible?  Yes  Yes  No    F#-first  Yes  Yes  Yes    Core Abstractions  scope { } and controller { }  HttpHandler  WebPart",
            "title": "Comparing servers"
        },
        {
            "location": "/safe-server/#why-saturn",
            "text": "Saturn is the default and recommended web server in SAFE .  Saturn (and Giraffe) runs on top of ASP .NET Core, which comes with an extremely high-performance server that is fully supported by Microsoft, has a huge community of developers and has excellent integration into cloud services such as Microsoft Azure and Amazon Web Services.  In addition, whilst the Giraffe and the Suave programming are extremely composable and fully functional-first, Saturn allows you to take advantage of abstractions such as  application { } ,  scope { }  and  controller { }  which are not only extremely simple to use but will also be familiar to developers from other (non-.NET) web programming models. And since Saturn's abstractions are all  optional , you can always fall back directly to the lower-level Giraffe model if required.  You'll probably find more samples online that use Suave at the time of writing. However, since Giraffe's programming model is similar to that of Suave, porting them across to Saturn / Giraffe is relatively easy to do.",
            "title": "Why Saturn?"
        },
        {
            "location": "/feature-client-server/",
            "text": "One of the most powerful features of SAFE is the ability to seamlessly share \ndata\n, \ntypes\n and \ncode\n across client and server.\n\n\nSharing Types\n\n\nSharing your domain types and contracts between client and server is extremely simple. Thanks to Fable's excellent F# transpilation into Javascript, you can use all standard F# language features such as Records, Tuples and Discriminated Unions without worry. To share types across both your client and server project, first create a file in your repository called e.g \nShared.fs\n.\n\n\n\nThen, create types in the file as needed e.g\n\n\ntype Customer = { Name : string }\n\n\n\n\nReference this file to your server project. You can now reference those types in the server.\n\n\n<Project Sdk=\"Microsoft.NET.Sdk\">\n    ...\n    <ItemGroup>\n        <Compile Include=\"../Shared/Shared.fs\" />\n    </ItemGroup>\n    ...\n</Project>\n\n\n\n\nFinally, reference this file to your client project (as above). You can now reference those types in the client; types will be compiled into Javascript types and seamlessly translated for you.\n\n\nSharing Code\n\n\nYou can also share code using the same mechanism. This is extremely useful for e.g shared validation or business logic that needs to occur on both client and server.\n\n\nFable will translate your functions into native Javascript, and will even translate many calls to the .NET base class library into corresponding Javascript! This allows you to compile your domain model and domain logic to many many different targets, ASP.NET Core (in Saturn), Azure Functions, Javascript that runs in the browser and Javascript that runs on mobile devices with \nReact Native\n. With .NET Core can even target things like the Raspberry Pi.\n\n\nYou can read more about this \non the Fable website\n.\n\n\nSharing Data\n\n\nSharing data can be achieved in two main ways in SAFE: through the \nSaturn\n API directly, or via the \nFable.Remoting\n library.\n\n\nSharing data with Saturn\n\n\nSharing data using Saturn is very simple. Start by creating a function in your server that returns some data:\n\n\nlet loadCustomersFromDb() =\n    [ { Name = \"Joe Bloggs\" } ]\n\n\n\n\nNext, create a method which returns the data as JSON within Giraffe's HTTP context.\n\n\n/// Returns the results of loadCustomersFromDb as JSON.\nlet getCustomers next ctx =\n    json (loadCustomersFromDb()) next ctx\n\n\n\n\nYou can opt to combine both of the above functions into one, depending on your preferences, but it's often good practice to separate your data access from serving data in HTTP endpoints.\n\n\nAlso note the \nnext\n and \nctx\n arguments. These are used by Giraffe as part of its \nHTTP pipeline\n and are required by the \njson\n function.\n\n\nNow expose the api method using \nSaturn's\n \nscope\n construct and add the scope to your overall application scope:\n\n\nlet myApis = scope {\n    get \"/api/customers/\" getCustomers\n}\n\n\n\n\nFor simple endpoints you may elect to embed the API call directly in the scope (and use partial application to omit the \nnext\n and \nctx\n arguments):\n\n\nlet myApis = scope {\n    get \"/api/customers/\" (json (loadCustomersFromDb()))\n}\n\n\n\n\nFinally, call the endpoint from your client application.\n\n\npromise {    \n    let! customers = Fetch.fetchAs<Customer array> (sprintf \"api/customers\") []\n    // do more with customers here...\n}\n\n\n\n\nNote the use of the \npromise { }\n computation expression. This functions like \nasync { }\n blocks that you already know, whilst the \nfetchAs\n function automatically deserializes the JSON back into a \nCustomer\n array.\n\n\nTurning on Fable's JSON Converter\n\n\nBy default, serialization between Fable and Giraffe \nis not compatible\n. In order to fix this, you must replace the JSON converter in Giraffe with Fable's own \nIJsonSerializer\n.\n\n\nIf you are using the dotnet SAFE Template, this will automatically be done for you - see the \nconfig\n function in \nServer.fs\n.\n\n\nSharing data using Fable.Remoting\n\n\nAs an alternative to raw HTTP, you can also use the \nFable.Remoting\n library, which provides an RPC-style mechanism for calling server endpoints.\n\n\nIn our case, instead of creating a \nscope { }\n on the server and using \nfetch\n on the client, you create a simple \nprotocol\n which contains methods exposed by the server:\n\n\ntype ICustomer = {\n    customers : unit -> Async<Customer array>\n}\n\nlet server : ICustomer = {\n    customers = fun () -> async { return loadCustomersFromDb() }\n}\n\n\n\n\nOn the client, you need only create a proxy for the protocol and then can call methods on it directly.\n\n\nasync {\n    let server = Proxy.remoting<ICustomer> {()}\n    let! customers = server.customers()\n    /// ...\n}\n\n\n\n\nNotice here, there is no need to create routes, or worry about HTTP verbs, or even involve yourself with the Giraffe pipeline.\n\n\nWhen should I use raw HTTP vs Fable Remoting?\n\n\nFable Remoting provides an excellent way to quickly get up and running with the SAFE stack. You can rapidly create contracts between client / server and have guaranteed contracts between both client and server. Remoting also forces all traffic as HTTP POSTs, which cannot be cached by the browser. If you're using a \"closed\" app without exposing an API to other consumers, and do not need close control of the HTTP channel, consider using Fable.Remoting.\n\n\nThe raw HTTP model with \nscope { }\n requires you to construct routes manually and does not guarantee that the client and endpoint have the same contract (you have to specify it on both sides yourself), but gives you total control over the routing and verbs used. If you have a public API that is exposed not just to your own application but to third-parties, or you need more fine grained control over your routes and data, you should stick with this approach.\n\n\n\n\n\n\n\n\n\n\nFable.Remoting\n\n\nRaw HTTP\n\n\n\n\n\n\n\n\n\n\nClient / Server\n\n\nVery simple\n\n\nSimple\n\n\n\n\n\n\nOpen API\n\n\nNo\n\n\nYes\n\n\n\n\n\n\nHTTP Verbs\n\n\nPOST only\n\n\nAll\n\n\n\n\n\n\nPipeline Control\n\n\nLimited\n\n\nFull",
            "title": "Client Server communication"
        },
        {
            "location": "/feature-client-server/#sharing-types",
            "text": "Sharing your domain types and contracts between client and server is extremely simple. Thanks to Fable's excellent F# transpilation into Javascript, you can use all standard F# language features such as Records, Tuples and Discriminated Unions without worry. To share types across both your client and server project, first create a file in your repository called e.g  Shared.fs .  Then, create types in the file as needed e.g  type Customer = { Name : string }  Reference this file to your server project. You can now reference those types in the server.  <Project Sdk=\"Microsoft.NET.Sdk\">\n    ...\n    <ItemGroup>\n        <Compile Include=\"../Shared/Shared.fs\" />\n    </ItemGroup>\n    ...\n</Project>  Finally, reference this file to your client project (as above). You can now reference those types in the client; types will be compiled into Javascript types and seamlessly translated for you.",
            "title": "Sharing Types"
        },
        {
            "location": "/feature-client-server/#sharing-code",
            "text": "You can also share code using the same mechanism. This is extremely useful for e.g shared validation or business logic that needs to occur on both client and server.  Fable will translate your functions into native Javascript, and will even translate many calls to the .NET base class library into corresponding Javascript! This allows you to compile your domain model and domain logic to many many different targets, ASP.NET Core (in Saturn), Azure Functions, Javascript that runs in the browser and Javascript that runs on mobile devices with  React Native . With .NET Core can even target things like the Raspberry Pi.  You can read more about this  on the Fable website .",
            "title": "Sharing Code"
        },
        {
            "location": "/feature-client-server/#sharing-data",
            "text": "Sharing data can be achieved in two main ways in SAFE: through the  Saturn  API directly, or via the  Fable.Remoting  library.",
            "title": "Sharing Data"
        },
        {
            "location": "/feature-client-server/#sharing-data-with-saturn",
            "text": "Sharing data using Saturn is very simple. Start by creating a function in your server that returns some data:  let loadCustomersFromDb() =\n    [ { Name = \"Joe Bloggs\" } ]  Next, create a method which returns the data as JSON within Giraffe's HTTP context.  /// Returns the results of loadCustomersFromDb as JSON.\nlet getCustomers next ctx =\n    json (loadCustomersFromDb()) next ctx  You can opt to combine both of the above functions into one, depending on your preferences, but it's often good practice to separate your data access from serving data in HTTP endpoints.  Also note the  next  and  ctx  arguments. These are used by Giraffe as part of its  HTTP pipeline  and are required by the  json  function.  Now expose the api method using  Saturn's   scope  construct and add the scope to your overall application scope:  let myApis = scope {\n    get \"/api/customers/\" getCustomers\n}  For simple endpoints you may elect to embed the API call directly in the scope (and use partial application to omit the  next  and  ctx  arguments):  let myApis = scope {\n    get \"/api/customers/\" (json (loadCustomersFromDb()))\n}  Finally, call the endpoint from your client application.  promise {    \n    let! customers = Fetch.fetchAs<Customer array> (sprintf \"api/customers\") []\n    // do more with customers here...\n}  Note the use of the  promise { }  computation expression. This functions like  async { }  blocks that you already know, whilst the  fetchAs  function automatically deserializes the JSON back into a  Customer  array.",
            "title": "Sharing data with Saturn"
        },
        {
            "location": "/feature-client-server/#turning-on-fables-json-converter",
            "text": "By default, serialization between Fable and Giraffe  is not compatible . In order to fix this, you must replace the JSON converter in Giraffe with Fable's own  IJsonSerializer .  If you are using the dotnet SAFE Template, this will automatically be done for you - see the  config  function in  Server.fs .",
            "title": "Turning on Fable's JSON Converter"
        },
        {
            "location": "/feature-client-server/#sharing-data-using-fableremoting",
            "text": "As an alternative to raw HTTP, you can also use the  Fable.Remoting  library, which provides an RPC-style mechanism for calling server endpoints.  In our case, instead of creating a  scope { }  on the server and using  fetch  on the client, you create a simple  protocol  which contains methods exposed by the server:  type ICustomer = {\n    customers : unit -> Async<Customer array>\n}\n\nlet server : ICustomer = {\n    customers = fun () -> async { return loadCustomersFromDb() }\n}  On the client, you need only create a proxy for the protocol and then can call methods on it directly.  async {\n    let server = Proxy.remoting<ICustomer> {()}\n    let! customers = server.customers()\n    /// ...\n}  Notice here, there is no need to create routes, or worry about HTTP verbs, or even involve yourself with the Giraffe pipeline.",
            "title": "Sharing data using Fable.Remoting"
        },
        {
            "location": "/feature-client-server/#when-should-i-use-raw-http-vs-fable-remoting",
            "text": "Fable Remoting provides an excellent way to quickly get up and running with the SAFE stack. You can rapidly create contracts between client / server and have guaranteed contracts between both client and server. Remoting also forces all traffic as HTTP POSTs, which cannot be cached by the browser. If you're using a \"closed\" app without exposing an API to other consumers, and do not need close control of the HTTP channel, consider using Fable.Remoting.  The raw HTTP model with  scope { }  requires you to construct routes manually and does not guarantee that the client and endpoint have the same contract (you have to specify it on both sides yourself), but gives you total control over the routing and verbs used. If you have a public API that is exposed not just to your own application but to third-parties, or you need more fine grained control over your routes and data, you should stick with this approach.      Fable.Remoting  Raw HTTP      Client / Server  Very simple  Simple    Open API  No  Yes    HTTP Verbs  POST only  All    Pipeline Control  Limited  Full",
            "title": "When should I use raw HTTP vs Fable Remoting?"
        },
        {
            "location": "/feature-ssr/",
            "text": "Server-Side Rendering (SSR) means that some parts of your application code can run on both the server and the client.\nFor \nReact\n this means that you can render your components directly to HTML on the server side (usually via a \nnode.js server\n), which allows for better search engine optimization (SEO) and gives a faster initial response, especially on mobile devices.\n\n\nThe browser typically receives a static HTML site and starts updating the UI immediately;\nReact's bundle code will be downloaded asynchronously and when it completes, the client-side JavaScript will take over via \nReact's hydrate\n functionality. In the JavaScript ecosystem this is also as known as an \"isomorphic\" or \"universal\" app.\n\n\nWhy use SSR?\n\n\nPros\n\n\n\n\nBetter SEO support, as web crawlers will directly see the fully rendered HTML page.\n\n\nFaster time-to-content, especially on slow internet connections or devices.\n\n\n\n\nCons\n\n\n\n\nSome development constraints. Browser-specific code requires some compiler directives to be ignored when running on the server.\n\n\nIncreased complexity of build and deployment processes.\n\n\nIncreased server-side load.\n\n\n\n\nSSR on SAFE\n\n\nIn SAFE, SSR can be done using \nfable-react\n. Its approach is a little different from those you might have seen in the JavaScript ecosystem, as it takes a purely F# approach: you render your \nElmish\n views directly on .NET Core, with all the benefits of the .NET Core runtime.\n\n\nFurther reading\n\n\n\n\nMore details can be found in the \nSSR tutorial\n.\n\n\nThe \nSAFE-BookStore\n sample project uses SSR.",
            "title": "Server Side Rendering"
        },
        {
            "location": "/feature-ssr/#why-use-ssr",
            "text": "",
            "title": "Why use SSR?"
        },
        {
            "location": "/feature-ssr/#pros",
            "text": "Better SEO support, as web crawlers will directly see the fully rendered HTML page.  Faster time-to-content, especially on slow internet connections or devices.",
            "title": "Pros"
        },
        {
            "location": "/feature-ssr/#cons",
            "text": "Some development constraints. Browser-specific code requires some compiler directives to be ignored when running on the server.  Increased complexity of build and deployment processes.  Increased server-side load.",
            "title": "Cons"
        },
        {
            "location": "/feature-ssr/#ssr-on-safe",
            "text": "In SAFE, SSR can be done using  fable-react . Its approach is a little different from those you might have seen in the JavaScript ecosystem, as it takes a purely F# approach: you render your  Elmish  views directly on .NET Core, with all the benefits of the .NET Core runtime.",
            "title": "SSR on SAFE"
        },
        {
            "location": "/feature-ssr/#further-reading",
            "text": "More details can be found in the  SSR tutorial .  The  SAFE-BookStore  sample project uses SSR.",
            "title": "Further reading"
        },
        {
            "location": "/feature-hmr/",
            "text": "Hot Module Replacement (HMR) allows to update the UI of an application while it is running, without a full reload. In SAFE stack apps, this can dramatically speed up the development for web and mobile GUIs, since there is no need to \"stop\" and \"reload\" and application. Instead, you can make changes to your views and have them immediately update in the browser, without the need to restart the application.\n\n\nHow does it work?\n\n\nIn case of web development, the \nwebpack\n development server will automatically refresh the changed parts of your \nelmish\n views whenever you save a file. Alternatively, in the case of mobile app development, this is achieved through \nReact Native\n's own bundler.\n\n\nWhy does it work so well with SAFE?\n\n\nSince SAFE uses the Model-View-Update architecture with immutable models, the application state only changes when a message is processed; this fits the HMR model very nicely. Here's an example of HMR in action to change the input of a textbox to automatically convert the input to upper case.\n\n\n\n\nFurther reading\n\n\n\n\nHot Module Replacement\n via webpack\n\n\nIntroducing Hot Reloading\n in React Native",
            "title": "Hot Module Replacement"
        },
        {
            "location": "/feature-hmr/#how-does-it-work",
            "text": "In case of web development, the  webpack  development server will automatically refresh the changed parts of your  elmish  views whenever you save a file. Alternatively, in the case of mobile app development, this is achieved through  React Native 's own bundler.",
            "title": "How does it work?"
        },
        {
            "location": "/feature-hmr/#why-does-it-work-so-well-with-safe",
            "text": "Since SAFE uses the Model-View-Update architecture with immutable models, the application state only changes when a message is processed; this fits the HMR model very nicely. Here's an example of HMR in action to change the input of a textbox to automatically convert the input to upper case.",
            "title": "Why does it work so well with SAFE?"
        },
        {
            "location": "/feature-hmr/#further-reading",
            "text": "Hot Module Replacement  via webpack  Introducing Hot Reloading  in React Native",
            "title": "Further reading"
        },
        {
            "location": "/learning/",
            "text": "This section contains useful repositories that allow you to learn more about the SAFE stack, at your own pace.\n\n\nTutorials\n\n\nSAFE Dojo\n\n\nThis dojo is a guided set of tasks designed to give you hands-on experience with the client and server components of the SAFE stack. You'll create server-side routes, client side UI and shared validation logic as you create a mashup application to provide details on UK locations.\n\n\nThe dojo takes around 90 minutes to complete if you have never worked with the stack before.\n\n\nSAFE Samples\n\n\nThe following example repositories (and more!) can be found in the official \nSAFE Stack\n organisational GitHub page.\n\n\nSAFE Bookstore\n\n\nThis sample demonstrates many of the useful features of a larger SAFE application, including login authentication using JWT tokens, automated deployment via Docker and SEO support with urls for pages. It also includes an example of using Azure Storage tables as a persistence store.\n\n\nSAFE ConfPlanner\n\n\nThis sample demonstrates how to build and share a complex domain model in SAFE across client and server, along with the use of websockets for a \"reactive\" UI support push notifications. It also demonstrates the use of F#'s flexible mailbox processors to implement an event-driven architecture.\n\n\nSAFE Search\n\n\nThis repository shows how to use Azure services to implement a SAFE application that supports searching over multiple data sources with support for find-ahead typing and throttling. The application uses a combination of Azure Search and Azure Storage Tables to construct a large search index that can rapidly find results in a number of ways.\n\n\nSAFE Chat\n\n\nThis application is a real-time chat application built on SAFE that uses the \nAKKA framework\n to manage actors that represent chat users, including Akka Streams and the Akkling F# library.\n\n\nSAFE Nightwatch\n\n\nThis application is a sample mobile application using the \nReact Native\n library, built on top of the SAFE stack. React Native permits a very similar programming when writing SAFE applications as browser applications, so the experience should be very familiar to you.\n\n\nVideos\n\n\n\n\nSAFE apps with F# web stack\n at F# Exchange 2018 (Tomasz Heimowski)\n\n\nModern app development with Fable and React Native\n at NDC Oslo 2017 (Steffen Forkmann)\n\n\n\n\nOther Resources\n\n\n\n\nThe Hanselminutes podcast: F# and the functional SAFE Stack\n with Krzysztof Cieslak",
            "title": "Learning Resources"
        },
        {
            "location": "/learning/#tutorials",
            "text": "",
            "title": "Tutorials"
        },
        {
            "location": "/learning/#safe-dojo",
            "text": "This dojo is a guided set of tasks designed to give you hands-on experience with the client and server components of the SAFE stack. You'll create server-side routes, client side UI and shared validation logic as you create a mashup application to provide details on UK locations.  The dojo takes around 90 minutes to complete if you have never worked with the stack before.",
            "title": "SAFE Dojo"
        },
        {
            "location": "/learning/#safe-samples",
            "text": "The following example repositories (and more!) can be found in the official  SAFE Stack  organisational GitHub page.",
            "title": "SAFE Samples"
        },
        {
            "location": "/learning/#safe-bookstore",
            "text": "This sample demonstrates many of the useful features of a larger SAFE application, including login authentication using JWT tokens, automated deployment via Docker and SEO support with urls for pages. It also includes an example of using Azure Storage tables as a persistence store.",
            "title": "SAFE Bookstore"
        },
        {
            "location": "/learning/#safe-confplanner",
            "text": "This sample demonstrates how to build and share a complex domain model in SAFE across client and server, along with the use of websockets for a \"reactive\" UI support push notifications. It also demonstrates the use of F#'s flexible mailbox processors to implement an event-driven architecture.",
            "title": "SAFE ConfPlanner"
        },
        {
            "location": "/learning/#safe-search",
            "text": "This repository shows how to use Azure services to implement a SAFE application that supports searching over multiple data sources with support for find-ahead typing and throttling. The application uses a combination of Azure Search and Azure Storage Tables to construct a large search index that can rapidly find results in a number of ways.",
            "title": "SAFE Search"
        },
        {
            "location": "/learning/#safe-chat",
            "text": "This application is a real-time chat application built on SAFE that uses the  AKKA framework  to manage actors that represent chat users, including Akka Streams and the Akkling F# library.",
            "title": "SAFE Chat"
        },
        {
            "location": "/learning/#safe-nightwatch",
            "text": "This application is a sample mobile application using the  React Native  library, built on top of the SAFE stack. React Native permits a very similar programming when writing SAFE applications as browser applications, so the experience should be very familiar to you.",
            "title": "SAFE Nightwatch"
        },
        {
            "location": "/learning/#videos",
            "text": "SAFE apps with F# web stack  at F# Exchange 2018 (Tomasz Heimowski)  Modern app development with Fable and React Native  at NDC Oslo 2017 (Steffen Forkmann)",
            "title": "Videos"
        },
        {
            "location": "/learning/#other-resources",
            "text": "The Hanselminutes podcast: F# and the functional SAFE Stack  with Krzysztof Cieslak",
            "title": "Other Resources"
        },
        {
            "location": "/support/",
            "text": "The following companies provide commercial training, support, consultancy and development services for SAFE Stack applications.\n\n\nCompositional IT\n\n\n\n\nCompositional IT are experts in designing functional-first, cloud-ready systems, offering consultancy and support, training and development. Run by an F# MVP and well-known member of the .NET community, they are dedicated to raising awareness of the benefits of both functional programming and harnessing the power of the cloud to deliver high-quality, low-cost solutions.\n\n\nLambda Factory\n\n\n\n\nLambda Factory is a consulting company specializing in designing and building complex systems using Functional Programming languages such as F#, Elm and Elixir. It also offers help with introducing functional programming and open source driven development to the organization, as well as trainings, workshops and mentoring. Founded by open source contributor and well-known member of F# Community, Lambda Factory has been committed to supporting F# Community and helping it grow.\n\n\nThe F# Community\n\n\nThe SAFE stack was written largely by the community as open source projects, such as Saturn, Giraffe, Fable and Elmish (as well as the alternative elements within the stack). All those teams are always happy to contribute and help out.\n\n\nSocial\n\n\nYou can also reach out to the SAFE team on \n@safe_stack\n or on the regular F# channels on Slack: either the official \nF# Foundation Slack\n or on the \nFunctional Programming Slack\n. We'll be expanding this over time.",
            "title": "Support"
        },
        {
            "location": "/support/#compositional-it",
            "text": "Compositional IT are experts in designing functional-first, cloud-ready systems, offering consultancy and support, training and development. Run by an F# MVP and well-known member of the .NET community, they are dedicated to raising awareness of the benefits of both functional programming and harnessing the power of the cloud to deliver high-quality, low-cost solutions.",
            "title": "Compositional IT"
        },
        {
            "location": "/support/#lambda-factory",
            "text": "Lambda Factory is a consulting company specializing in designing and building complex systems using Functional Programming languages such as F#, Elm and Elixir. It also offers help with introducing functional programming and open source driven development to the organization, as well as trainings, workshops and mentoring. Founded by open source contributor and well-known member of F# Community, Lambda Factory has been committed to supporting F# Community and helping it grow.",
            "title": "Lambda Factory"
        },
        {
            "location": "/support/#the-f-community",
            "text": "The SAFE stack was written largely by the community as open source projects, such as Saturn, Giraffe, Fable and Elmish (as well as the alternative elements within the stack). All those teams are always happy to contribute and help out.",
            "title": "The F# Community"
        },
        {
            "location": "/support/#social",
            "text": "You can also reach out to the SAFE team on  @safe_stack  or on the regular F# channels on Slack: either the official  F# Foundation Slack  or on the  Functional Programming Slack . We'll be expanding this over time.",
            "title": "Social"
        },
        {
            "location": "/testimonials/",
            "text": "Please feel free to submit a PR to add testimonials to this page!\n\n\nmsu solutions GmbH\n\n\n\n\nSAFE gives us a fast development cycle for our web and mobile platforms\n\n\n\n\nWe at \nmsu solutions GmbH\n are big fans of SAFE stack. For the last couple of years we were already using F# open source technologies for web and mobile projects. Tools like the Fable compiler and elmish are rock solid and a pleasure to work with.\n\n\nSince the release of SAFE, we see that all these important technologies are now bundled and tested under one big umbrella. \nEspecially the commercial support for SAFE is very important for us and our customers.",
            "title": "Testimonials"
        },
        {
            "location": "/testimonials/#msu-solutions-gmbh",
            "text": "SAFE gives us a fast development cycle for our web and mobile platforms   We at  msu solutions GmbH  are big fans of SAFE stack. For the last couple of years we were already using F# open source technologies for web and mobile projects. Tools like the Fable compiler and elmish are rock solid and a pleasure to work with.  Since the release of SAFE, we see that all these important technologies are now bundled and tested under one big umbrella. \nEspecially the commercial support for SAFE is very important for us and our customers.",
            "title": "msu solutions GmbH"
        }
    ]
}